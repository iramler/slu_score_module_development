---
title: "Bootstrap work"
format: html
editor: visual
---

```{r}
library(readr)
library(tidyverse)
library(dplyr)
library(magrittr)
library(caret)

timeout <- read.csv("slhess20/data/timeout.csv")
```

```{r}
#filter data to only be slu timeouts in 2014 only
timeout1 <- timeout %>% 
  filter(play_descripton == "Timeout St. Lawrence.", 
         ) 
timeout1 <- timeout1[grepl("^2019", timeout1$Date), ]
library(dplyr)
timeout1 <- timeout1 %>% 
  mutate(losing_score = ifelse(prev_home_score > prev_visiting_score, prev_visiting_score, prev_home_score))


timeout1 <- timeout1 %>% 
  select(url, timeout, set,prev_home_score, prev_visiting_score, losing_score, losing_team, set_winner, losing_team_wins)
#timeout1 <- timeout1 %>% 
 # group_by(url)

tally <- timeout1 %>% 
  mutate(losing_score = ifelse(losing_team == "home", prev_home_score, prev_visiting_score), 
         winning_score = ifelse(losing_team == "home", prev_visiting_score, prev_home_score),
         point_diff = winning_score - losing_score,
         timeout_ind = ifelse(timeout == TRUE, 1, 0)) %>% 
  select(losing_score, winning_score, set, url, timeout_ind, point_diff, losing_team_wins)

# get distribution of how many points team has when timeout is called
# tally 

# pull previous data for timeout
# timeout team score vs other team 
# 3 columns table your score/ other team score/ timeout

# model num timeouts based on the point differential.

```

```{r}
# Visualize distribution of points when timeout is called
win_diff <- tally %>% filter(losing_team_wins)

ggplot(tally, aes(x = winning_score - losing_score)) +
  geom_histogram(binwidth = 1, fill = "pink", color = "black") +
  labs(title = "Diff of score When Timeout is Called",
       x = "Losing Team's Score", y = "Frequency")




```

```{r}
# Compute observed frequencies for each point differential
observed_freq <- table(tally$losing_score[tally$set == 1])

observed_values <- as.numeric(names(observed_freq))

n <- sum(observed_freq)
p <- 1 / (1 + mean(tally$point_diff[tally$timeout_ind == 1]))
expected_prob <- dgeom(observed_values, prob = p)

# Normalize expected probabilities to sum up to 1
expected_prob <- expected_prob / sum(expected_prob) * n

# Perform chi-square goodness-of-fit test
chi_sq_test <- chisq.test(observed_freq, p = expected_prob)

# Print the results
print(chi_sq_test)


```

